---
title: "Overview"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Why is `independencepvalue` needed?

```{r classical, echo = FALSE}
library(independencepvalue)
p <- 6
n <- 9
Sigma <- create_example(p, a = 0.6, b = 0.3)
set.seed(9768)
X <- MASS::mvrnorm(n=n, rep(0, p), Sigma)
```

```{r thresholding_alt_overview, echo = FALSE, fig.show='hide'}
block_diag_structure <- independencepvalue::block_diag(cor(X), c=0.5, fig=TRUE)
```

```{r classcial_alt_overview, echo = FALSE}
classical_p_val <- classical_p_val(S=cov(X), CP=block_diag_structure, k=1, n=n, mc_iter=1000)
```

```{r selective_alt_overview, echo = FALSE}
selective_p_val <- selective_p_val(S=cov(X), CP=block_diag_structure, k=1, n=n, c=0.5, d0=5, mc_iter=1000)
```

In theory, one should decide on the hypotheses to test before seeing the data. However, in practice, scientists often want to find something seemingly interesting in the data and then use it to test if it is really interesting. When we generate a hypothesis based on a data set and then use the same data set to test the hypothesis, classical hypothesis testing may lead to invalid results.

To illustrate: we consider a simulated dataset, where the variables are correlated (as shown in the heatmap of the absolute entries of the absolute and sample correlation matrix). In this dataset, we first identify groups of seemingly uncorrelated variables via thresholding the correlation matrix. We want to test the null hypothesis that they are really uncorrelated. A classical approach based on Wilks' lambda distribution yielded a p-value of `r classical_p_val`, even when the variables are correlated in the population! This shows how ignoring the fact that the hypothesis was selected from the data can lead to a tremendous loss of power.

```{r plot, echo = FALSE, fig.height = 4.5, fig.width = 8, fig.align = "center", dpi = 100}
graphics::par(mfrow=c(1,2))
    graphics::image(t(Sigma)[,ncol(Sigma):1], main="Absolute population correlation", col=rev(grDevices::heat.colors(10)), xaxt='n', yaxt='n')
    graphics::image(t(abs(cor(X)))[,ncol(abs(cor(X))):1], main="Absolute sample correlation", col=rev(grDevices::heat.colors(10)), xaxt='n', yaxt='n')
```

This is where `independencepvalue` comes into play. It accounts for the fact that the hypothesis was generated by thresholding the correlation matrix of the data. Applying `independencepvalue` in the aforementioned scenario leads to a p-value of `r 
round(selective_p_val, 3)`. Unlike classical inference, this test correctly identifies the group of variables to be correlated. To know more about how to use `independencepvalue`, please see the [Tutorial](articles/Tutorial.html). 

# How does `independencepvalue` work?
`independencepvalue` works in two stages:

 1. First, we threshold the absolute values of the observed correlation matrix to partition the variables into groups of seemingly uncorrelated variables. 
 2. Next, we take a selective inference approach to test if a group of variables (obtained in the previous step) is independent of the remaining variables. Here, unlike the classical approach, we do not ignore that the hypothesis was generated from the data. We account for this by conditioning on the event that the grouping of the variables that generated the hypothesis is recovered. We adjust the null distribution to account for the selection of the particular hypothesis being tested. By restricting attention to specifically those datasets that would have led to this hypothesis being selected, we are able to account for the selection effect.

For more details, please see our paper, [Inferring independent sets of Gaussian variables after thresholding correlations](XXXX.arxiv.org).



